---
alwaysApply: true
---
# NodeGraph智能Timeline自动生成系统

## 🎯 核心任务目标
对NodeGraph SO文件中的所有FlowEventNode节点，智能遍历和分析timeline描述信息，自动选择合适的timeline模板和clip2样式，生成相应的timeline并填充回NodeGraph中。

##⚠️ 重要修改说明
**默认clip2样式已从 `default_bounce_animation` 更改为 `camera_focus_only`**
- 当物体timeline内容描述不明确或无法匹配到具体操作类型时，使用 `camera_focus_only` 作为默认选项
- 只有明确的按压操作描述才使用 `default_bounce_animation`
- 这样可以避免不合适的弹跳动画效果

## 🏗️ Timeline创建架构说明

### TimelineManager统一管理
- **统一PlayableDirector**: 所有timeline共享一个TimelineManager物体上的PlayableDirector组件
- **自动创建机制**: 如果场景中不存在名为"TimelineManager"的物体，系统会自动创建：
  - 创建空GameObject命名为"TimelineManager"
  - 添加PlayableDirector组件
  - 添加TimelineManager.cs脚本（路径：Assets/NodeGraphTool/Runtime/Manager）
  - 设置参数：目标timeline为当前PlayableDirector，是否需要实例化为true
- **复用机制**: 如果已存在TimelineManager，直接使用其PlayableDirector组件进行timeline创建

### Timeline绑定管理
- **绑定注册系统**: 每个创建的Timeline都会自动注册其轨道与物体的绑定关系到TimelineManager的PlayableDirector
- **自动组件添加**: 系统会自动为需要的物体添加Animator组件
- **绑定信息记录**: 创建结果中包含详细的绑定信息，格式为"轨道名 -> 物体名"
- **Timeline复制机制**: TimelineManager.cs中的ResetTimelineBinding方法会在播放时将绑定复制到临时的PlayableDirector

## 💡 智能Timeline生成策略

### 核心判断规则
基于NodeGraph中四个关键字段的分析进行智能选择：
- **相机timeline名称** (camera_timeline_name)
- **相机timeline内容** (camera_timeline_content)  
- **物体timeline名称** (object_timeline_name)
- **物体timeline内容** (object_timeline_content)

### 生成方式自动选择

#### **规则1: 纯相机聚焦模式**
```
触发条件：
- "物体timeline名称" 为空或包含 ["-", "无", "空", "null", "none", "跳过"]
- "物体timeline内容" 为空或包含 ["-", "无", "空", "null", "none", "跳过"]

生成方式：
使用 camera_closeup_animation 生成聚焦观察timeline

特点：
- 纯相机动画，无物体操作
- 适合观察、检查、查看类场景
- 相机聚焦到目标物体后返回原位置
```

#### **规则2: 三段式组合模式**
```
触发条件：
- "物体timeline名称" 不为空且有具体内容
- "物体timeline内容" 不为空且有具体内容

生成方式：
使用 generate_combined_timeline 生成三段式组合timeline

特点：
- Clip1: 相机从当前位置移动到物体操作位置
- Clip2: 执行物体操作动画（根据物体timeline内容选择clip2样式）
- Clip3: 相机从操作位置返回到原始位置
- 三个clip无缝衔接，形成完整的操作流程
```

## 🎬 Clip2样式智能选择系统

### 基于物体timeline内容的样式匹配

当使用generate_combined_timeline时，系统会根据"物体timeline内容"的描述自动选择最合适的clip2样式。

**⚠️ 重要原则**: 如果物体timeline内容描述不明确或无法匹配到具体的物体操作类型，**默认使用camera_focus_only而不是default_bounce_animation**。

#### **倾倒液体类型 - pour_liquid**
```
关键词匹配：
- "倾倒"、"倒入"、"倒出"、"注入"、"pour"
- "液体"、"溶液"、"试剂"、"水"
- "从XX到YY"、"XX倒入YY"

应用场景：
- 比色皿倾倒到废液烧杯
- 试剂瓶倒入比色皿
- 任何液体转移操作

物体顺序要求：
第一个物体：需要倾倒的容器（主动物体）
其他物体：接收液体的容器（目标物体）
```

#### **插入连接类型 - insert_power_cable**
```
关键词匹配：
- "插入"、"连接"、"接入"、"insert"、"connect"
- "电源线"、"电缆"、"插头"、"线缆"
- "插到XX"、"连接到XX"

应用场景：
- 电源线插入设备
- 连接线缆到仪器
- 任何插入式连接操作

物体顺序要求：
第一个物体：需要插入的线缆（主动物体）
其他物体：被插入的设备（目标物体）
```

#### **物体移入类型 - move_object_into**
```
关键词匹配：
- "放入"、"移入"、"装入"、"置入"、"move into"
- "放到XX中"、"移动到XX"、"装进XX"

应用场景：
- 比色皿放入样品室
- 物品装入容器
- 任何物体移入操作

物体顺序要求：
第一个物体：需要移动的物体（主动物体）
其他物体：目标容器或位置（目标物体）
```

#### **穿戴操作类型 - wear_gloves**
```
关键词匹配：
- "穿戴"、"戴上"、"戴"、"wear"、"put on"
- "手套"、"gloves"、"防护用品"

应用场景：
- 戴手套
- 穿戴防护设备
- 任何穿戴类操作

物体顺序要求：
通常只涉及单个物体（手套）
```

#### **书写记录类型 - notebook_writing**
```
关键词匹配：
- "书写"、"记录"、"填写"、"写"、"writing"
- "笔记本"、"记录本"、"表格"、"notebook"
- "记录数据"、"填写信息"

应用场景：
- 实验数据记录
- 笔记本书写
- 任何记录类操作

物体顺序要求：
通常只涉及单个物体（笔记本）
```

#### **按压操作类型 - default_bounce_animation**
```
关键词匹配：
- "按下"、"按压"、"点击"、"press"、"click"
- "按钮"、"开关"、"button"、"switch"
- "启动"、"开启"、"关闭"

应用场景：
- 按下设备按钮
- 操作开关
- 明确的按压类操作

物体顺序要求：
通常只涉及单个物体（按钮）
```

#### **纯相机聚焦 - camera_focus_only**
```
关键词匹配：
- "观察"、"查看"、"检查"、"观看"、"focus"
- "聚焦"、"特写"、"close-up"
- 无具体物体操作描述

应用场景：
- 纯观察类动作
- 检查设备状态
- 无物体交互的聚焦

物体顺序要求：
目标物体作为聚焦对象
```

## 📋 详细执行流程

### 第一步：获取NodeGraph信息
```
使用以下MCP函数获取基础信息：
1. get_flow_event_node_names(name="NodeGraphName", path="NodeGraphPath") 
   # 获取所有FlowEventNode节点名称列表

2. find_camera_objects() 
   # 获取场景中的相机对象

3. get_all_scene_objects() 
   # 获取所有可用物体

物体查找规则：
- Main Camera：直接在场景根目录下
- 所有实验物体：存放在GameObjectRoot物体下作为子物体
- 查找物体时需要在GameObjectRoot下搜索（除相机外）
```

### 第二步：遍历所有FlowEventNode节点
```
对每个FlowEventNode执行以下分析：

1. 使用 get_flow_event_node_by_name(name="NodeGraphName", event_name="节点名称")
   提取四个关键字段：
   - camera_timeline_name （相机timeline名称）
   - camera_timeline_content （相机timeline内容）
   - object_timeline_name （物体timeline名称）
   - object_timeline_content （物体timeline内容）

2. 执行智能判断逻辑
3. 选择合适的生成方式
4. 生成相应的timeline
5. 关联回NodeGraph节点
```

### 第三步：智能判断与生成

#### **判断逻辑流程图**
```
开始处理节点
    ↓
检查 object_timeline_name 和 object_timeline_content
    ↓
┌─────────────────┬─────────────────┐
│  物体timeline为空  │  物体timeline不为空  │
│  或包含跳过关键词   │  且有具体描述内容   │
└─────────────────┴─────────────────┘
    ↓                     ↓
使用 camera_closeup      使用 generate_combined
_animation 生成          _timeline 生成三段式
纯相机聚焦timeline       组合timeline
    ↓                     ↓
┌─────────────────┐  ┌─────────────────┐
│ 分析相机timeline   │  │ 1.分析相机timeline │
│ 内容，提取目标物体  │  │ 2.分析物体timeline │
│ 生成聚焦动画      │  │ 3.选择clip2样式   │
└─────────────────┘  │ 4.生成三段式动画   │
                     └─────────────────┘
```

#### **具体生成调用**

**方式1：纯相机聚焦**
```python
# 当物体timeline为空时调用
camera_closeup_animation(
    camera_name="Main Camera",
    target_object_name="从相机timeline内容中识别的目标物体",
    duration=6,  # 根据复杂度调整
    timeline_asset_name="节点名称_相机聚焦",
    move_to_start=True,
    return_to_origin=True
)
```

**方式2：三段式组合**
```python
# 当物体timeline不为空时调用
generate_combined_timeline(
    timeline_name="节点名称_组合动画",
    target_object_name="物体名称,相关物体名称",  # 主动物体在前
    clip2_function_name="根据物体timeline内容选择的clip2样式",
    interaction_objects=["物体1", "物体2", ...],  # 从描述中提取
    camera_name="Main Camera",
    clip_duration=5,  # 根据动画复杂度调整
    operation_object_name="主操作物体名称",
    enable_smart_positioning=True,
    desk_object_name="实验桌",
    fov=45,
    pitch_angle=35,
    padding=1.2,
    force_reset_rotation_y=True
)
```

### 第四步：物体识别与参数处理

#### **目标物体智能识别**
```
从timeline内容描述中提取物体名称：

1. 正则表达式匹配模式：
   - 中文物体名称：[\u4e00-\u9fa5]+
   - 英文物体名称：[A-Za-z][A-Za-z0-9_]*
   - 数字编号：\d+

2. 场景物体查找：
   - 使用 find_objects_by_name_pattern() 进行模糊匹配
   - 相机类物体：在场景根目录下查找
   - 实验物体：在GameObjectRoot下查找所有子物体
   - 支持中英文物体名称混合识别

3. 物体顺序处理：
   - 对于需要交互的timeline，确保主动物体在前
   - 被动物体（目标、容器）在后
   - 保持物体操作的逻辑顺序
```

#### **Clip2样式自动选择**
```python
def select_clip2_style(object_timeline_content):
    """
    根据物体timeline内容自动选择clip2样式
    """
    content = object_timeline_content.lower()
    
    # 倾倒液体类型
    if any(keyword in content for keyword in 
           ["倾倒", "倒入", "倒出", "注入", "pour", "液体", "溶液"]):
        return "pour_liquid"
    
    # 插入连接类型  
    elif any(keyword in content for keyword in 
             ["插入", "连接", "接入", "insert", "connect", "电源线", "插头"]):
        return "insert_power_cable"
    
    # 物体移入类型
    elif any(keyword in content for keyword in 
             ["放入", "移入", "装入", "置入", "move into"]):
        return "move_object_into"
    
    # 穿戴操作类型
    elif any(keyword in content for keyword in 
             ["穿戴", "戴上", "戴", "wear", "put on", "手套", "gloves"]):
        return "wear_gloves"
    
    # 书写记录类型
    elif any(keyword in content for keyword in 
             ["书写", "记录", "填写", "写", "writing", "笔记本", "notebook"]):
        return "notebook_writing"
    
    # 按压操作类型
    elif any(keyword in content for keyword in 
             ["按下", "按压", "点击", "press", "click", "按钮", "开关"]):
        return "default_bounce_animation"
    
    # 纯观察类型
    elif any(keyword in content for keyword in 
             ["观察", "查看", "检查", "观看", "focus", "聚焦"]):
        return "camera_focus_only"
    
    # ⚠️ 默认使用纯相机聚焦（而非弹跳动画）
    else:
        return "camera_focus_only"
```

### 第五步：Timeline关联与保存

#### **Timeline资产关联**
```python
# 根据生成的timeline类型进行关联

# 方式1：camera_closeup_animation 生成的聚焦timeline
update_flow_event_node_timeline_assets(
    name="NodeGraphName",
    event_name="节点名称",
    camera_timeline_asset="Assets/Timeline/节点名称_相机聚焦.playable",
    object_timeline_asset=None  # 纯相机timeline，无物体timeline
)

# 方式2：generate_combined_timeline 生成的组合timeline  
update_flow_event_node_timeline_assets(
    name="NodeGraphName",
    event_name="节点名称",
    camera_timeline_asset="Assets/Timeline/节点名称_组合动画.playable",
    object_timeline_asset=None  # 组合timeline只生成一个资产文件
)
```

#### **批量保存**
```python
# 处理完所有节点后统一保存
save_nodegraph_changes(name="NodeGraphName", path="NodeGraphPath")
```

### 第六步：错误处理与日志

#### **错误处理策略**
```
1. 物体识别失败：
   - 尝试模糊匹配相似名称的物体
   - 使用默认目标物体（如"实验桌"）
   - 记录警告信息但继续执行

2. Clip2样式识别失败：
   - 使用默认的 "camera_focus_only"（而非default_bounce_animation）
   - 记录使用默认样式的原因

3. Timeline生成失败：
   - 记录详细错误信息
   - 跳过当前节点，继续处理下一个
   - 在最终报告中列出失败节点

4. 节点关联失败：
   - 记录关联失败的timeline资产路径
   - 不影响其他节点的处理
```

#### **详细进度显示**
```
=== NodeGraph智能Timeline自动生成 ===
目标NodeGraph: Example.asset
节点总数: 15个

[1/15] 处理节点: "检查器具齐全"
  ├─ 相机timeline: "检查器具齐全_镜头" | 内容: "使用聚焦timeline格式..."
  ├─ 物体timeline: "" | 内容: ""
  ├─ 判断结果: 物体timeline为空 → 使用camera_closeup_animation
  ├─ 目标物体: "实验桌"
  ├─ 生成结果: ✅成功
  └─ Timeline资产: "Assets/Timeline/检查器具齐全_相机聚焦.playable"

[2/15] 处理节点: "连接仪器电源"
  ├─ 相机timeline: "连接仪器电源_镜头" | 内容: "镜头从当前点位出发..."
  ├─ 物体timeline: "连接仪器电源_电源线" | 内容: "电源线从目前点位平移到..."
  ├─ 判断结果: 物体timeline不为空 → 使用generate_combined_timeline
  ├─ Clip2样式: insert_power_cable (检测到关键词: 电源线, 插入)
  ├─ 目标物体: "电源线,紫外可见光分光仪"
  ├─ 生成结果: ✅成功
  └─ Timeline资产: "Assets/Timeline/连接仪器电源_组合动画.playable"

[3/15] 处理节点: "按下电源按钮"
  ├─ 相机timeline: "按下电源按钮_镜头" | 内容: "镜头从当前点位出发..."
  ├─ 物体timeline: "按下电源按钮_电源按钮" | 内容: "电源按钮向下按压2mm..."
  ├─ 判断结果: 物体timeline不为空 → 使用generate_combined_timeline
  ├─ Clip2样式: default_bounce_animation (检测到关键词: 按下, 按钮)
  ├─ 目标物体: "电源按钮"
  ├─ 生成结果: ✅成功
  └─ Timeline资产: "Assets/Timeline/按下电源按钮_组合动画.playable"

...

=== 生成统计报告 ===
总节点数: 15
成功生成: 14
跳过处理: 1 (原因: timeline内容为空)
失败节点: 0

生成方式分布:
- camera_closeup_animation: 6个
- generate_combined_timeline: 8个

Clip2样式分布:
- insert_power_cable: 1个
- default_bounce_animation: 4个
- move_object_into: 2个
- pour_liquid: 1个

所有Timeline已成功关联到NodeGraph并保存完成！
```

## 🔧 系统配置参数

### **默认配置**
```python
TIMELINE_CONFIG = {
    # 基础参数
    "camera_name": "Main Camera",
    "default_duration": 6.0,
    "default_clip_duration": 5.0,
    "move_to_start": True,
    "return_to_origin": True,
    
    # 相机参数
    "default_fov": 45,
    "default_pitch_angle": 35,
    "default_padding": 1.2,
    "force_reset_rotation_y": True,
    
    # 空值关键词
    "skip_keywords": ["-", "无", "空", "null", "none", "跳过", "", " "],
    
    # 场景结构
    "scene_structure": {
        "camera_parent": None,  # 相机在场景根目录
        "objects_parent": "GameObjectRoot",  # 实验物体在GameObjectRoot下
        "desk_object_name": "实验桌"
    },
    
    # Timeline管理器
    "timeline_manager": {
        "name": "TimelineManager",
        "script_path": "Assets/NodeGraphTool/Runtime/Manager/TimelineManager.cs",
        "auto_create": True
    }
}
```

### **Clip2样式关键词配置**
```python
CLIP2_KEYWORDS = {
    "pour_liquid": ["倾倒", "倒入", "倒出", "注入", "pour", "液体", "溶液", "试剂"],
    "insert_power_cable": ["插入", "连接", "接入", "insert", "connect", "电源线", "插头", "线缆"],
    "move_object_into": ["放入", "移入", "装入", "置入", "move into", "放到", "装进"],
    "wear_gloves": ["穿戴", "戴上", "戴", "wear", "put on", "手套", "gloves"],
    "notebook_writing": ["书写", "记录", "填写", "写", "writing", "笔记本", "notebook", "记录本"],
    "default_bounce_animation": ["按下", "按压", "点击", "press", "click", "按钮", "开关", "button"],
    "camera_focus_only": ["观察", "查看", "检查", "观看", "focus", "聚焦", "特写"]
}
```

## 🚀 完整执行指令

### **立即执行命令**
```
请你作为AI助手，现在开始执行NodeGraph SO文件的智能Timeline自动生成工作。

目标NodeGraph：
- 名称："NodeGraphName" 
- 路径："NodeGraphPath"

执行规则：
1. 遍历NodeGraph中所有FlowEventNode节点的timeline描述信息
2. 智能分析四个字段：相机timeline名称、相机timeline内容、物体timeline名称、物体timeline内容
3. 根据物体timeline是否为空选择生成方式：
   - 物体timeline为空 → camera_closeup_animation（纯相机聚焦）
   - 物体timeline不为空 → generate_combined_timeline（三段式组合）
4. 对于三段式组合，根据物体timeline内容智能选择clip2样式
5. 生成timeline并关联回NodeGraph节点
6. 保存所有修改

场景结构说明：
- 相机物体：在场景根目录下查找
- 实验物体：在GameObjectRoot物体下查找
- 系统会自动创建TimelineManager进行统一管理

请详细显示每个节点的处理过程，包括：
- 提取的四个timeline字段内容
- 判断逻辑和选择的生成方式
- 识别的目标物体和clip2样式（如适用）
- 生成结果和timeline资产路径
- 错误信息（如有）

最后提供完整的统计报告。现在开始执行！
```

### **使用示例**
```
# 替换NodeGraphName和NodeGraphPath为实际值
请执行以下NodeGraph的智能Timeline生成：

目标NodeGraph：
- 名称："紫外可见光光度计测量实验_v1.0_20241217"
- 路径："Assets/紫外可见光光度计测量实验"

立即开始智能分析和生成！
```

## 📋 总结

本系统实现了完全自动化的Timeline生成流程：
1. **智能遍历**：自动遍历NodeGraph中所有timeline描述
2. **智能判断**：基于物体timeline是否为空进行生成方式选择
3. **智能匹配**：根据描述内容自动选择最合适的clip2样式
4. **智能关联**：自动将生成的timeline关联回NodeGraph节点
5. **统一管理**：使用TimelineManager进行统一的timeline管理

通过这套系统，可以实现从NodeGraph描述到实际timeline的完全自动化转换，大大提高timeline创建效率和准确性。



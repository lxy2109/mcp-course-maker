from mcp.server.fastmcp import FastMCP, Context
from typing import List, Dict, Any, Optional
import json
import re
from unity_connection import get_unity_connection
import math

def register_animation_tools(mcp):
    """注册动画相关工具"""
    
    # mcp.tool()(create_movement_animation)
    
    mcp.tool()(create_multipoint_animation)
    mcp.tool()(rotate_around_target_animation)
    
    mcp.tool()(camera_panorama_animation)
    mcp.tool()(camera_sweep_animation)
    mcp.tool()(camera_closeup_animation)
    mcp.tool()(get_timeline_asset_path)
    mcp.tool()(verify_timeline_asset_exists)
    
    # 新增复合timeline生成函数
    mcp.tool()(generate_separate_timelines)
    mcp.tool()(generate_combined_timeline)
    mcp.tool()(parse_timeline_description)
    
    # 新增智能避障便捷函数
    mcp.tool()(create_smart_movement_animation)
    mcp.tool()(create_safe_camera_movement)
    # mcp.tool()(create_movement_clip)
    # mcp.tool()(create_multipoint_clip)
    # mcp.tool()(rotate_around_target_clip)
    # mcp.tool()(create_timeline_with_clips)

def create_movement_animation(
    ctx: Context,
    name: str,
    points: Optional[List[Dict[str, Any]]] = None,
    start_position: Optional[Dict[str, Any]] = None,
    end_position: Optional[Dict[str, Any]] = None,
    start_rotation: Optional[Dict[str, Any]] = None,
    end_rotation: Optional[Dict[str, Any]] = None,
    duration: float = 2.0,
    timeline_asset_name: str = "AutoGeneratedTimeline",
    include_rotation: bool = False,
    keyframes: Optional[List[Dict[str, Any]]] = None,
    path_type: str = "linear",  # 路径类型参数: linear, curve, bezier
    move_to_start: bool = True,  # 是否在timeline开始前将物体从当前位置移动到动画起始位置
    return_to_origin: bool = False,  # 是否在timeline结束后将物体从结束位置移回原始位置
    # 新增避障参数
    enable_obstacle_avoidance: bool = False,  # 是否启用避障功能
    obstacle_detection_radius: float = 0.5,  # 障碍物检测半径
    avoidance_height: float = 2.0,  # 避障时的额外高度
    obstacle_layers: Optional[List[str]] = None,  # 要检测的障碍物层级
    max_avoidance_attempts: int = 3  # 最大避障尝试次数
) -> str:
    """为指定物体创建移动和旋转动画，支持多点路径和智能避障。

    参数：
        ctx: MCP 上下文
        name: 要创建动画的物体名称
        points: 多点路径列表，格式为 [{"position": {"x": 0, "y": 0, "z": 0}, "time": 0.0}, ...]
        start_position: 起始位置，格式为
            start_position = {
                "x": 0.0,
                "y": 0.0,
                "z": 0.0
            }
            默认为当前位置
        end_position: 结束位置，格式为
            end_position = {
                "x": 0.0,
                "y": 0.0,
                "z": 5.0
            }
            默认为(0,0,5)
        start_rotation: 起始旋转，格式为
            start_rotation = {
                "x": 0.0,
                "y": 90.0,
                "z": 0.0
            }
            默认为当前旋转
        end_rotation: 结束旋转，格式为
            start_rotation = {
                "x": 0.0,
                "y": 90.0,
                "z": 0.0
            }
            默认为当前旋转
        duration: 动画持续时间（秒）
        timeline_asset_name: Timeline资产名称
        include_rotation: 是否包含旋转动画
        keyframes: 多点关键帧数组，每个关键帧包含time和position/rotation（向后兼容）
        path_type: 路径类型，可选值："linear"（线性）, "curve"（曲线）, "bezier"（贝塞尔曲线）
        move_to_start: 是否在timeline开始前将物体从当前位置移动到动画起始位置
        return_to_origin: 是否在timeline结束后将物体从结束位置移回原始位置
        enable_obstacle_avoidance: 是否启用避障功能
        obstacle_detection_radius: 障碍物检测半径（米）
        avoidance_height: 避障时的额外高度（米）
        obstacle_layers: 要检测的障碍物层级名称列表，如["Default", "Obstacle"]
        max_avoidance_attempts: 最大避障尝试次数

    返回值：
        str: 成功消息或错误详情
    """
    try:
        # 处理多点输入，points参数优先级高于keyframes
        processed_keyframes = None

        if points is not None:
            # 使用新的points参数格式
            processed_keyframes = []
            for point in points:
                processed_point = {}

                # 处理时间
                if "time" in point:
                    processed_point["time"] = point["time"]
                elif len(processed_keyframes) > 0:
                    processed_point["time"] = processed_keyframes[-1]["time"] + 1.0
                else:
                    processed_point["time"] = 0.0

                # 处理位置
                if "position" in point and isinstance(point["position"], dict):
                    processed_point["position"] = {
                        "x": float(point["position"].get("x", 0.0)),
                        "y": float(point["position"].get("y", 0.0)),
                        "z": float(point["position"].get("z", 0.0))
                    }

                # 处理旋转
                if "rotation" in point and isinstance(point["rotation"], dict):
                    processed_point["rotation"] = {
                        "x": float(point["rotation"].get("x", 0.0)),
                        "y": float(point["rotation"].get("y", 0.0)),
                        "z": float(point["rotation"].get("z", 0.0))
                    }

                if processed_point:
                    processed_keyframes.append(processed_point)

        # 如果没有points参数，则使用keyframes参数（向后兼容）
        elif keyframes is not None:
            processed_keyframes = []
            for kf in keyframes:
                processed_kf = {}
                if "time" in kf:
                    processed_kf["time"] = kf["time"]

                if "position" in kf and isinstance(kf["position"], dict):
                    processed_kf["position"] = {
                        "x": float(kf["position"].get("x", 0.0)),
                        "y": float(kf["position"].get("y", 0.0)),
                        "z": float(kf["position"].get("z", 0.0))
                    }

                if "rotation" in kf and isinstance(kf["rotation"], dict):
                    processed_kf["rotation"] = {
                        "x": float(kf["rotation"].get("x", 0.0)),
                        "y": float(kf["rotation"].get("y", 0.0)), 
                        "z": float(kf["rotation"].get("z", 0.0))
                    }

                if processed_kf:
                    processed_keyframes.append(processed_kf)

        # 准备命令参数
        command_params = {
            "name": name,
            "duration": duration,
            "timeline_asset_name": timeline_asset_name,
            "include_rotation": include_rotation,
            "path_type": path_type,  # 添加路径类型
            "move_to_start": move_to_start,  # 添加新参数
            "return_to_origin": return_to_origin,  # 添加新参数
            # 添加避障参数
            "enable_obstacle_avoidance": enable_obstacle_avoidance,
            "obstacle_detection_radius": obstacle_detection_radius,
            "avoidance_height": avoidance_height,
            "obstacle_layers": obstacle_layers if obstacle_layers else ["Default"],
            "max_avoidance_attempts": max_avoidance_attempts
        }

        # 只有当这些参数不是None时才添加到请求中，并确保所有值为浮点数
        if start_position is not None:
            # 创建新字典并明确转换为浮点数
            command_params["start_position"] = {
                "x": float(start_position.get("x", 0.0)),
                "y": float(start_position.get("y", 0.0)),
                "z": float(start_position.get("z", 0.0))
            }
        if end_position is not None:
            command_params["end_position"] = {
                "x": float(end_position.get("x", 0.0)),
                "y": float(end_position.get("y", 0.0)),
                "z": float(end_position.get("z", 5.0))
            }
        if start_rotation is not None:
            command_params["start_rotation"] = {
                "x": float(start_rotation.get("x", 0.0)),
                "y": float(start_rotation.get("y", 0.0)),
                "z": float(start_rotation.get("z", 0.0))
            }
        if end_rotation is not None:
            command_params["end_rotation"] = {
                "x": float(end_rotation.get("x", 0.0)),
                "y": float(end_rotation.get("y", 90.0)),
                "z": float(end_rotation.get("z", 0.0))
            }

        if processed_keyframes is not None:
            command_params["keyframes"] = processed_keyframes

        # 发送命令到Unity
        response = get_unity_connection().send_command("CREATE_MOVEMENT_ANIMATION", command_params)

        # 处理返回结果
        success = response.get("success", False)
        message = response.get("message", "未知状态")
        obstacles_detected = response.get("obstacles_detected", 0)
        avoidance_applied = response.get("avoidance_applied", False)

        if success:
            result_message = message
            if enable_obstacle_avoidance:
                result_message += f"\n避障信息: 检测到 {obstacles_detected} 个障碍物"
                if avoidance_applied:
                    result_message += "，已应用避障路径"
                else:
                    result_message += "，未需要避障"
            return result_message
        else:
            return f"创建动画失败: {message}"

    except Exception as e:
        return f"创建动画时出错：{str(e)}"




def create_multipoint_animation(
        ctx: Context,
        name: str,
        points: List[Dict[str, Any]],
        duration: float = 5.0,
        timeline_asset_name: str = "MultipointAnimation",
        include_rotation: bool = False,
        path_type: str = "linear",
        move_to_start: bool = True,  # 新增参数
        return_to_origin: bool = False,  # 新增参数
        # 新增避障参数
        enable_obstacle_avoidance: bool = False,
        obstacle_detection_radius: float = 0.5,
        avoidance_height: float = 2.0,
        obstacle_layers: Optional[List[str]] = None,
        max_avoidance_attempts: int = 3
) -> str:
    """创建多点路径动画，可以指定多个路径点。

    参数：
        ctx: MCP 上下文
        name: 要创建动画的物体名称
        points: 路径点列表，每个点必须包含position，可选包含rotation和time
            例如: [
                {"position": {"x": 0, "y": 0, "z": 0}},
                {"position": {"x": 5, "y": 2, "z": 3}, "time": 2.5},
                {"position": {"x": 0, "y": 5, "z": 0}, "rotation": {"x": 0, "y": 180, "z": 0}}
            ]
        duration: 整个动画的持续时间（秒）
        timeline_asset_name: Timeline资产名称
        include_rotation: 是否包含旋转动画
        path_type: 路径类型，可选值："linear", "curve", "bezier"
        move_to_start: 是否在timeline开始前将物体从当前位置移动到动画起始位置
        return_to_origin: 是否在timeline结束后将物体从结束位置移回原始位置
        enable_obstacle_avoidance: 是否启用避障功能
        obstacle_detection_radius: 障碍物检测半径（米）
        avoidance_height: 避障时的额外高度（米）
        obstacle_layers: 要检测的障碍物层级名称列表
        max_avoidance_attempts: 最大避障尝试次数

    返回值：
        str: 成功消息或错误详情
    """
    try:
        # 如果没有提供足够的点，返回错误
        if not points or len(points) < 2:
            return "创建多点动画需要至少两个路径点"
        
        # 对没有指定时间的点进行时间分配
        points_with_time = []
        points_without_time = []
        
        # 首先收集有时间和没时间的点
        for point in points:
            if "time" in point:
                points_with_time.append(point)
            else:
                points_without_time.append(point)
        
        # 如果没有任何点有时间，均匀分配时间
        if not points_with_time:
            for i, point in enumerate(points):
                point_copy = point.copy()
                point_copy["time"] = duration * i / (len(points) - 1)
                points_with_time.append(point_copy)
        else:
            # 如果有些点有时间，需要为其他点插值时间
            # 首先排序已有时间的点
            points_with_time.sort(key=lambda p: p["time"])
            
            # 确保第一个和最后一个点有时间
            if points[0] not in points_with_time:
                points[0]["time"] = 0.0
                points_with_time.insert(0, points[0])
            
            if points[-1] not in points_with_time:
                points[-1]["time"] = duration
                points_with_time.append(points[-1])
            
            # 为中间没有时间的点插值时间
            final_points = points_with_time.copy()
            for point in points_without_time:
                if point in points_with_time:
                    continue
                    
                # 找到此点在原始点列表中的位置
                original_index = points.index(point)
                
                # 找到前后有时间的点
                prev_time_point = None
                next_time_point = None
                prev_idx = original_index - 1
                next_idx = original_index + 1
                
                while prev_idx >= 0 and prev_time_point is None:
                    if points[prev_idx] in points_with_time:
                        for p in points_with_time:
                            if p == points[prev_idx]:
                                prev_time_point = p
                                break
                    prev_idx -= 1
                    
                while next_idx < len(points) and next_time_point is None:
                    if points[next_idx] in points_with_time:
                        for p in points_with_time:
                            if p == points[next_idx]:
                                next_time_point = p
                                break
                    next_idx += 1
                
                # 根据前后点的时间插值
                if prev_time_point and next_time_point:
                    prev_time = prev_time_point["time"]
                    next_time = next_time_point["time"]
                    prev_index = points.index(prev_time_point)
                    next_index = points.index(next_time_point)
                    
                    # 计算当前点在前后两点之间的相对位置
                    if next_index > prev_index:
                        ratio = (original_index - prev_index) / (next_index - prev_index)
                        point_copy = point.copy()
                        point_copy["time"] = prev_time + ratio * (next_time - prev_time)
                        final_points.append(point_copy)
                
            # 确保所有点时间在0到duration之间
            for point in final_points:
                if point["time"] < 0:
                    point["time"] = 0
                elif point["time"] > duration:
                    point["time"] = duration
            
            # 按时间排序
            final_points.sort(key=lambda p: p["time"])
            points_with_time = final_points
        
        # 调用修改后的create_movement_animation
        return create_movement_animation(
            ctx=ctx,
            name=name,
            points=points_with_time,
            duration=duration,
            timeline_asset_name=timeline_asset_name,
            include_rotation=include_rotation,
            path_type=path_type,
            move_to_start=move_to_start,
            return_to_origin=return_to_origin,
            enable_obstacle_avoidance=enable_obstacle_avoidance,
            obstacle_detection_radius=obstacle_detection_radius,
            avoidance_height=avoidance_height,
            obstacle_layers=obstacle_layers,
            max_avoidance_attempts=max_avoidance_attempts
        )

    except Exception as e:
        return f"创建多点动画时出错：{str(e)}"



def rotate_around_target_animation(
        ctx: Context,
        moving_object_name: str,
        target_object_name: str,
        radius: float,
        height: float,
        duration: float,
        timeline_asset_name: str = "RotationAroundTarget",
        look_at_target: bool = False,
        move_to_start: bool = True,  # 新增参数
        return_to_origin: bool = False  # 新增参数
) -> str:
    """
    让一个物体围绕目标物体旋转，创建动画。在开始时直接瞬移到第一个围绕位置。

    参数：
        ctx: MCP 上下文
        moving_object_name: 需要移动的物体名称（如相机）
        target_object_name: 目标物体名称（如胶囊体）
        radius: 旋转半径
        height: 旋转时的高度偏移
        duration: 动画持续时间（秒）
        timeline_asset_name: Timeline资产名称
        look_at_target: 是否让移动物体始终朝向目标物体
        move_to_start: 是否在timeline开始前将物体从当前位置移动到动画起始位置
        return_to_origin: 是否在timeline结束后将物体从结束位置移回原始位置

    返回值：
        str: 成功消息或错误详情
    """
    try:
        # 获取目标物体的信息
        target_info = get_unity_connection().send_command("GET_OBJECT_INFO", {"name": target_object_name})
        if not target_info.get("success", False):
            return f"获取目标物体信息失败: {target_info.get('message', '未知错误')}"

        # 提取目标物体的位置
        target_position = {
            "x": target_info["position"][0],
            "y": target_info["position"][1],
            "z": target_info["position"][2]
        }

        # 获取移动物体的信息（仅用于获取初始旋转）
        moving_object_info = get_unity_connection().send_command("GET_OBJECT_INFO", {"name": moving_object_name})
        if not moving_object_info.get("success", False):
            return f"获取移动物体信息失败: {moving_object_info.get('message', '未知错误')}"
        
        # 提取移动物体的初始旋转
        moving_object_rotation = {
            "x": moving_object_info["rotation"][0],
            "y": moving_object_info["rotation"][1],
            "z": moving_object_info["rotation"][2]
        }

        # 计算围绕目标物体的路径点
        points = []
        total_steps = 12
        
        # 不再使用初始位置的过渡点，直接从第一个围绕位置开始
        for step in range(total_steps + 1):
            angle = (step / total_steps) * 360
            radian = math.radians(angle)
            x = target_position["x"] + radius * math.sin(radian)
            z = target_position["z"] - radius * math.cos(radian)
            point = {
                "position": {"x": x, "y": target_position["y"] + height, "z": z},
                "time": (step / total_steps) * duration
            }

            # 如果需要朝向目标，计算旋转角度
            if look_at_target:
                point["rotation"] = {"x": math.degrees(math.atan2(height, radius)), "y": moving_object_rotation["y"] - angle, "z": 0}

            points.append(point)

        # 调用 create_movement_animation 创建动画
        return create_movement_animation(
            ctx=ctx,
            name=moving_object_name,
            points=points,
            duration=duration,
            timeline_asset_name=timeline_asset_name,
            include_rotation=True,
            move_to_start=move_to_start,
            return_to_origin=return_to_origin
        )

    except Exception as e:
        return f"创建围绕目标物体旋转动画时出错：{str(e)}"

    

# 创建相机360度环视动画，相机将在原地旋转一周，可调整俯仰角。
def camera_panorama_animation(
        ctx: Context,
        camera_name: str = "Main Camera",
        pitch_angle: float = -20.0,  # 俯仰角度，正值向上，负值向下
        duration: float = 10.0,
        timeline_asset_name: str = "CameraPanorama",
        steps: int = 24,  # 旋转分段数量，值越大越平滑
        move_to_start: bool = True,  # 新增参数
        return_to_origin: bool = False,  # 新增参数
) -> str:
    """
    创建相机360度环视动画，相机将在原地旋转一周，可调整俯仰角。
    没有指定参数是默认俯视10，

    参数：
        ctx: MCP 上下文
        camera_name: 相机对象名称，默认为"Main Camera"
        pitch_angle: 俯仰角度，正值向下看，负值向上看
        duration: 动画持续时间（秒）
        timeline_asset_name: Timeline资产名称
        steps: 旋转分段数量，值越大动画越平滑
        move_to_start: 是否在timeline开始前将相机从当前位置移动到动画起始位置
        return_to_origin: 是否在timeline结束后将相机从结束位置移回原始位置

    返回值：
        str: 成功消息或错误详情
    """
    try:
        # 获取相机信息
        camera_info = get_unity_connection().send_command("GET_OBJECT_INFO", {"name": camera_name})
        if not camera_info.get("success", False):
            return f"获取相机信息失败: {camera_info.get('message', '未知错误')}"

        # 提取相机当前位置和旋转信息
        camera_position = {
            "x": camera_info["position"][0],
            "y": camera_info["position"][1],
            "z": camera_info["position"][2]
        }
        
        initial_rotation = {
            "x": camera_info["rotation"][0],
            "y": camera_info["rotation"][1],
            "z": camera_info["rotation"][2]
        }

        # 创建360度环视的路径点
        points = []
        
        # 设置俯仰角
        pitch = pitch_angle
        
        # 生成一系列旋转角度的点
        for step in range(steps + 1):
            angle = (step / steps) * 360  # 0到360度
            point = {
                "position": camera_position,  # 位置保持不变
                "rotation": {
                    "x": pitch,  # 固定的俯仰角
                    "y": initial_rotation["y"] + angle,  # 水平旋转角度
                    "z": 0  # z轴旋转通常为0
                },
                "time": (step / steps) * duration
            }
            points.append(point)

        # 调用create_movement_animation创建动画
        return create_movement_animation(
            ctx=ctx,
            name=camera_name,
            points=points,
            duration=duration,
            timeline_asset_name=timeline_asset_name,
            include_rotation=True,  # 必须包含旋转
            path_type="linear",  # 线性路径，因为仅旋转而不移动
            move_to_start=move_to_start,
            return_to_origin=return_to_origin
        )

    except Exception as e:
        return f"创建相机环视动画时出错：{str(e)}"


# 创建相机扫视动画，相机将从左前方扫视到右前方，然后回到正前方，可调整俯仰角和扫视角度。
def camera_sweep_animation(
        ctx: Context,
        camera_name: str = "Main Camera",
        pitch_angle: float = 0.0,  # 俯仰角度，正值向上看，负值向下看
        sweep_angle: float = 45.0,  # 扫视角度范围（单侧角度，实际范围是 -sweep_angle 到 +sweep_angle）
        duration: float = 8.0,
        timeline_asset_name: str = "CameraSweep",
        steps: int = 18,  # 每段路径的分段数量，值越大越平滑
        move_to_start: bool = True,  # 是否在timeline开始前将相机从当前位置移动到动画起始位置
        return_to_origin: bool = False  # 是否在timeline结束后将相机从结束位置移回原始位置
) -> str:
    """
    创建相机扫视动画，相机将从左前方扫视到右前方，然后回到正前方，可调整俯仰角和扫视角度。

    参数：
        ctx: MCP 上下文
        camera_name: 相机对象名称，默认为"Main Camera"
        pitch_angle: 俯仰角度，正值向上看，负值向下看
        sweep_angle: 扫视角度范围（单侧角度，实际范围是 -sweep_angle 到 +sweep_angle）
        duration: 动画持续时间（秒）
        timeline_asset_name: Timeline资产名称
        steps: 每段路径的分段数量，值越大动画越平滑
        move_to_start: 是否在timeline开始前将相机从当前位置移动到动画起始位置
        return_to_origin: 是否在timeline结束后将相机从结束位置移回原始位置

    返回值：
        str: 成功消息或错误详情
    """
    try:
        # 获取相机信息
        camera_info = get_unity_connection().send_command("GET_OBJECT_INFO", {"name": camera_name})
        if not camera_info.get("success", False):
            return f"获取相机信息失败: {camera_info.get('message', '未知错误')}"

        # 提取相机当前位置和旋转信息
        camera_position = {
            "x": camera_info["position"][0],
            "y": camera_info["position"][1],
            "z": camera_info["position"][2]
        }

        initial_rotation = {
            "x": camera_info["rotation"][0],
            "y": camera_info["rotation"][1],
            "z": camera_info["rotation"][2]
        }

        # 创建扫视动画的路径点
        points = []

        # 确保sweep_angle为正值
        sweep_angle = abs(sweep_angle)
        
        # 调整时间分配，使左到右的过程速度为原来的0.3倍
        
        duration = duration * 2
        
        # 计算各阶段时间分配
        segment1_duration = duration * 0.15 
        segment2_duration = duration * 0.7 
        segment3_duration = duration * 0.15 
        
        
        
        # 计算时间点
        time_left = segment1_duration
        time_right = time_left + segment2_duration

        # 第一段：从中间到左侧
        for step in range(steps + 1):
            progress = step / steps
            current_time = progress * segment1_duration
            current_angle = progress * (-sweep_angle)  # 从0到-sweep_angle
            point = {
                "position": camera_position,  # 位置保持不变
                "rotation": {
                    "x": pitch_angle,  # 固定的俯仰角
                    "y": initial_rotation["y"] + current_angle,  # 水平旋转角度
                    "z": 0  # z轴旋转通常为0
                },
                "time": current_time
            }
            points.append(point)

        # 第二段：从左侧到右侧（放慢速度）
        for step in range(steps + 1):
            progress = step / steps
            current_time = time_left + progress * segment2_duration
            current_angle = -sweep_angle + progress * (2 * sweep_angle)  # 从-sweep_angle到+sweep_angle
            point = {
                "position": camera_position,  # 位置保持不变
                "rotation": {
                    "x": pitch_angle,  # 固定的俯仰角
                    "y": initial_rotation["y"] + current_angle,  # 水平旋转角度
                    "z": 0  # z轴旋转通常为0
                },
                "time": current_time
            }
            points.append(point)

        # 第三段：从右侧回到中间
        for step in range(steps + 1):
            progress = step / steps
            current_time = time_right + progress * segment3_duration
            current_angle = sweep_angle - progress * sweep_angle  # 从+sweep_angle到0
            point = {
                "position": camera_position,  # 位置保持不变
                "rotation": {
                    "x": pitch_angle,  # 固定的俯仰角
                    "y": initial_rotation["y"] + current_angle,  # 水平旋转角度
                    "z": 0  # z轴旋转通常为0
                },
                "time": current_time
            }
            points.append(point)

        # 调用create_movement_animation创建动画
        return create_movement_animation(
            ctx=ctx,
            name=camera_name,
            points=points,
            duration=duration,
            timeline_asset_name=timeline_asset_name,
            include_rotation=True,  # 必须包含旋转
            path_type="linear",  # 线性路径，因为仅旋转而不移动
            move_to_start=move_to_start,
            return_to_origin=return_to_origin
        )

    except Exception as e:
        return f"创建相机扫视动画时出错：{str(e)}"


# 创建相机特写动画，镜头从原位置移动到目标物体周围进行特写，然后回到原始位置。
def camera_closeup_animation(
        ctx: Context,
        camera_name: str = "Main Camera",
        target_object_name: str = None,
        closeup_distance: float = 5.0,  # 特写距离，默认为前方5个单位
        pitch_angle: float = 10.0,  # 俯仰视角度，正值向下看
        horizontal_angle: float = 60.0,  # 水平扫视范围角度
        duration: float = 10.0,  # 只表示从左前方移动到右前方的时间
        timeline_asset_name: str = "CameraCloseup",
        move_speed: float = 5.0,  # 相机移动速度，单位：米/秒
        move_to_start: bool = True,
        return_to_origin: bool = False
) -> str:
    """
    创建相机特写动画，镜头从原位置移动到目标物体周围进行特写，然后回到原始位置。

    动画流程：
    1. 镜头从原位置移动到物体的左前方（时间根据距离和速度自动计算）
    2. 镜头从左前方缓慢移动到右前方（使用指定的duration时间）
    3. 镜头从右前方回到原来位置（时间根据距离和速度自动计算）

    参数：
        ctx: MCP 上下文
        camera_name: 相机对象名称，默认为"Main Camera"
        target_object_name: 目标物体名称，必须指定
        closeup_distance: 特写时与目标物体的距离
        pitch_angle: 特写时的俯仰角度
        horizontal_angle: 水平扫视范围角度
        duration: 从左前方移动到右前方的时间（秒）
        timeline_asset_name: Timeline资产名称
        move_speed: 相机移动速度（米/秒），用于计算其他阶段的时间
        move_to_start: 是否在timeline开始前将相机从当前位置移动到动画起始位置
        return_to_origin: 是否在timeline结束后将相机从结束位置移回原始位置

    返回值：
        str: 成功消息或错误详情
    """
    try:
        # 检查目标物体是否存在
        if target_object_name is None:
            return "目标物体名称不能为空"

        # 获取相机信息
        camera_info = get_unity_connection().send_command("GET_OBJECT_INFO", {"name": camera_name})
        if not camera_info.get("success", False):
            return f"获取相机信息失败: {camera_info.get('message', '未知错误')}"

        # 获取目标物体信息
        target_info = get_unity_connection().send_command("GET_OBJECT_INFO", {"name": target_object_name})
        if not target_info.get("success", False):
            return f"获取目标物体信息失败: {target_info.get('message', '未知错误')}"

        # 提取相机当前位置和旋转信息
        camera_position = {
            "x": camera_info["position"][0],
            "y": camera_info["position"][1],
            "z": camera_info["position"][2]
        }
        
        camera_rotation = {
            "x": camera_info["rotation"][0],
            "y": camera_info["rotation"][1],
            "z": camera_info["rotation"][2]
        }

        # 提取目标物体位置
        target_position = {
            "x": target_info["position"][0],
            "y": target_info["position"][1],
            "z": target_info["position"][2]
        }

        # 计算特写位置
        # 计算左前方位置
        left_angle_rad = math.radians(target_info["rotation"][1] - horizontal_angle/2)
        left_position = {
            "x": target_position["x"] + closeup_distance * math.sin(left_angle_rad),
            "y": target_position["y"],
            "z": target_position["z"] + closeup_distance * math.cos(left_angle_rad)
        }
        
        # 计算右前方位置
        right_angle_rad = math.radians(target_info["rotation"][1] + horizontal_angle/2)
        right_position = {
            "x": target_position["x"] + closeup_distance * math.sin(right_angle_rad),
            "y": target_position["y"],
            "z": target_position["z"] + closeup_distance * math.cos(right_angle_rad)
        }

        # 计算各段距离
        def calculate_distance(pos1, pos2):
            return math.sqrt(
                (pos1["x"] - pos2["x"]) ** 2 + 
                (pos1["y"] - pos2["y"]) ** 2 + 
                (pos1["z"] - pos2["z"]) ** 2
            )
        
        distance_to_left = calculate_distance(camera_position, left_position)
        distance_left_to_right = calculate_distance(left_position, right_position)
        distance_right_to_origin = calculate_distance(right_position, camera_position)
        
        # 计算各段时间
        time_to_left = distance_to_left / move_speed
        time_left_to_right = duration  # 使用指定的duration
        time_right_to_origin = distance_right_to_origin / move_speed
        
        # 计算总时间
        total_duration = time_to_left + time_left_to_right + time_right_to_origin
        
        # 创建关键帧
        points = []
        
        # 初始位置关键帧
        points.append({
            "position": camera_position,
            "rotation": camera_rotation,
            "time": 0
        })
        
        # 计算朝向目标物体的旋转
        def look_at_target(from_pos):
            dx = target_position["x"] - from_pos["x"]
            dz = target_position["z"] - from_pos["z"]
            yaw = math.degrees(math.atan2(dx, dz))
            return {
                "x": pitch_angle,
                "y": yaw,
                "z": 0
            }
        
        # 左前方关键帧
        points.append({
            "position": left_position,
            "rotation": look_at_target(left_position),
            "time": time_to_left
        })
        
        # 右前方关键帧
        points.append({
            "position": right_position,
            "rotation": look_at_target(right_position),
            "time": time_to_left + time_left_to_right
        })
        
        # 回到原始位置关键帧
        points.append({
            "position": camera_position,
            "rotation": camera_rotation,
            "time": total_duration
        })
        
        # 调用create_movement_animation创建动画
        return create_movement_animation(
            ctx=ctx,
            name=camera_name,
            points=points,
            duration=total_duration,
            timeline_asset_name=timeline_asset_name,
            include_rotation=True,
            path_type="curve",  # 使用曲线路径让移动更平滑
            move_to_start=move_to_start,
            return_to_origin=return_to_origin
        )

    except Exception as e:
        return f"创建相机特写动画时出错：{str(e)}"


def get_timeline_asset_path(
    ctx: Context,
    timeline_name: str,
    search_folder: str = "Assets"
) -> str:
    """
    获取Timeline资产的完整路径

    参数：
        ctx: MCP 上下文
        timeline_name: Timeline资产名称
        search_folder: 搜索文件夹，默认为"Assets"

    返回值：
        str: Timeline资产路径信息或错误详情
    """
    try:
        unity = get_unity_connection()
        
        # 发送命令到Unity
        response = unity.send_command("GET_TIMELINE_ASSET_PATH", {
            "timeline_name": timeline_name,
            "search_folder": search_folder
        })
        
        # 处理返回结果
        success = response.get("success", False)
        
        if success:
            found_count = response.get("foundCount", 0)
            primary_path = response.get("primaryPath")
            all_paths = response.get("paths", [])
            
            if found_count == 0:
                return f"未找到名为 '{timeline_name}' 的Timeline资产"
            elif found_count == 1:
                return f"找到Timeline资产: {primary_path}"
            else:
                paths_list = "\n".join([f"  - {path}" for path in all_paths])
                return f"找到 {found_count} 个匹配的Timeline资产:\n{paths_list}\n主要路径: {primary_path}"
        else:
            message = response.get("message", "未知错误")
            return f"获取Timeline资产路径失败: {message}"
            
    except Exception as e:
        return f"获取Timeline资产路径时出错：{str(e)}"


def verify_timeline_asset_exists(
    ctx: Context,
    asset_path: str
) -> str:
    """
    验证Timeline资产是否存在

    参数：
        ctx: MCP 上下文
        asset_path: Timeline资产的完整路径

    返回值：
        str: 验证结果信息或错误详情
    """
    try:
        unity = get_unity_connection()

        # 发送命令到Unity
        response = unity.send_command("VERIFY_TIMELINE_ASSET_EXISTS", {
            "asset_path": asset_path
        })

        # 处理返回结果
        success = response.get("success", False)

        if success:
            exists = response.get("exists", False)
            file_exists = response.get("fileExists", False)
            asset_in_database = response.get("assetInDatabase", False)
            message = response.get("message", "")
            asset_info = response.get("assetInfo")
            
            result = f"Timeline资产验证结果:\n"
            result += f"  路径: {asset_path}\n"
            result += f"  存在状态: {message}\n"
            result += f"  文件存在: {'是' if file_exists else '否'}\n"
            result += f"  在Unity数据库中: {'是' if asset_in_database else '否'}\n"
            
            if asset_info:
                result += f"  资产信息:\n"
                result += f"    名称: {asset_info.get('name', 'N/A')}\n"
                result += f"    持续时间: {asset_info.get('duration', 'N/A')} 秒\n"
                result += f"    轨道数量: {asset_info.get('trackCount', 'N/A')}\n"
                result += f"    GUID: {asset_info.get('guid', 'N/A')}\n"
            
            return result
        else:
            message = response.get("message", "未知错误")
            return f"验证Timeline资产失败: {message}"

    except Exception as e:
        return f"验证Timeline资产时出错：{str(e)}"


def generate_separate_timelines(
    ctx: Context,
    camera_timeline_name: str,
    camera_timeline_content: str,
    object_timeline_name: str,
    object_timeline_content: str,
    target_object_name: str = None,
    camera_name: str = "Main Camera"
) -> str:
    """
    生成分离的两个timeline：先生成镜头timeline，再生成物体timeline

    参数：
        ctx: MCP 上下文
        camera_timeline_name: 镜头timeline名称
        camera_timeline_content: 镜头timeline内容描述
        object_timeline_name: 物体timeline名称  
        object_timeline_content: 物体timeline内容描述
        target_object_name: 目标物体名称
        camera_name: 相机名称，默认为"Main Camera"
        
    返回值：
        str: 生成结果信息
    """
    try:
        # 解析镜头timeline内容
        camera_params = parse_timeline_description(ctx, camera_timeline_content, camera_name, target_object_name)
        if "error" in camera_params:
            return f"解析镜头timeline内容失败: {camera_params['error']}"
            
        # 解析物体timeline内容
        object_params = parse_timeline_description(ctx, object_timeline_content, target_object_name, target_object_name)
        if "error" in object_params:
            return f"解析物体timeline内容失败: {object_params['error']}"
        
        # 生成镜头timeline
        camera_params['timeline_asset_name'] = camera_timeline_name
        camera_result = execute_animation_function(ctx, camera_params)
        
        if "失败" in camera_result or "错误" in camera_result:
            return f"生成镜头timeline失败: {camera_result}"
            
        # 生成物体timeline
        object_params['timeline_asset_name'] = object_timeline_name
        object_result = execute_animation_function(ctx, object_params)
        
        if "失败" in object_result or "错误" in object_result:
            return f"生成物体timeline失败: {object_result}"
        
        return f"成功生成分离的timelines:\n镜头timeline: {camera_result}\n物体timeline: {object_result}"
        
    except Exception as e:
        return f"生成分离timelines时出错：{str(e)}"


def generate_combined_timeline(
    ctx: Context,
    timeline_name: str,
    camera_timeline_content: str,
    object_timeline_content: str,
    target_object_name: str,
    camera_name: str = "Main Camera",
    clip_duration: float = 5.0
) -> str:
    """
    生成组合的单个timeline，包含3个clip：镜头移动到物体前 -> 物体动画 -> 镜头移回初始位置
    
    参数：
        ctx: MCP 上下文
        timeline_name: 组合timeline名称
        camera_timeline_content: 镜头timeline内容描述
        object_timeline_content: 物体timeline内容描述
        target_object_name: 目标物体名称
        camera_name: 相机名称，默认为"Main Camera"
        clip_duration: 每个clip的基础持续时间
        
    返回值：
        str: 生成结果信息
    """
    try:
        # 解析动画内容
        camera_params = parse_timeline_description(ctx, camera_timeline_content, camera_name, target_object_name)
        object_params = parse_timeline_description(ctx, object_timeline_content, target_object_name, target_object_name)
        
        if "error" in camera_params:
            return f"解析镜头内容失败: {camera_params['error']}"
        if "error" in object_params:
            return f"解析物体内容失败: {object_params['error']}"
        
        # 发送命令到Unity创建组合timeline
        response = get_unity_connection().send_command("CREATE_COMBINED_TIMELINE", {
            "timeline_name": timeline_name,
            "camera_name": camera_name,
            "target_object_name": target_object_name,
            "camera_params": camera_params,
            "object_params": object_params,
            "clip_duration": clip_duration
        })
        
        success = response.get("success", False)
        message = response.get("message", "未知状态")
        
        if success:
            return f"成功生成组合timeline: {message}"
        else:
            return f"生成组合timeline失败: {message}"

    except Exception as e:
        return f"生成组合timeline时出错：{str(e)}"


def parse_timeline_description(
        ctx: Context,
    description: str,
    object_name: str,
    target_object_name: str = None
) -> Dict[str, Any]:
    """
    解析自然语言描述的timeline内容，转换为具体的动画参数

    参数：
        ctx: MCP 上下文
        description: 自然语言描述
        object_name: 要操作的物体名称
        target_object_name: 目标物体名称（可选）
        
    返回值：
        Dict[str, Any]: 解析后的动画参数
    """
    try:
        description = description.lower().strip()
        
        # 围绕目标旋转 - 移到相机判断外面，适用于所有物体
        if any(keyword in description for keyword in ['围绕', '绕着', '环绕']) and target_object_name:
            return {
                'function': 'rotate_around_target_animation',
                'moving_object_name': object_name,
                'target_object_name': target_object_name,
                'radius': extract_distance(description, default=5.0),
                'height': extract_height(description, default=2.0),
                'duration': extract_duration(description, default=8.0)
            }
        
        # 相机动画模式识别
        if any(keyword in description for keyword in ['镜头', '相机', '摄像', 'camera']):
            # 环视动画
            if any(keyword in description for keyword in ['环视', '360', '旋转一圈', '转圈', '环绕']):
                return {
                    'function': 'camera_panorama_animation',
                    'name': object_name,
                    'pitch_angle': extract_angle(description, default=-20.0),
                    'duration': extract_duration(description, default=10.0)
                }
            
            # 扫视动画 
            elif any(keyword in description for keyword in ['扫视', '左右', '扫射', '摆动']):
                return {
                    'function': 'camera_sweep_animation',
                    'name': object_name,
                    'pitch_angle': extract_angle(description, default=0.0),
                    'sweep_angle': extract_sweep_angle(description, default=45.0),
                    'duration': extract_duration(description, default=8.0)
                }
            
            # 特写动画
            elif any(keyword in description for keyword in ['特写', '靠近', '接近', '拉近']):
                if target_object_name is None:
                    return {'error': '特写动画需要指定目标物体'}
                return {
                    'function': 'camera_closeup_animation',
                    'name': object_name,
                    'target_object_name': target_object_name,
                    'closeup_distance': extract_distance(description, default=3.0),
                    'duration': extract_duration(description, default=10.0)
                }

        # 物体移动动画
        if any(keyword in description for keyword in ['移动', '运动', '位移', '移到']):
            # 解析移动目标位置
            target_position = extract_position(description)
            if target_position:
                # 创建起点和终点，确保至少有两个点
                return {
                    'function': 'create_multipoint_animation',
                    'name': object_name,
                    'points': [
                        {'position': {'x': 0, 'y': 0, 'z': 0}},  # 起点
                        {'position': target_position}  # 终点
                    ],
                    'duration': extract_duration(description, default=3.0)
                }
        
        # 旋转动画
        if any(keyword in description for keyword in ['旋转', '转动', '转向']):
            rotation = extract_rotation(description)
            if rotation:
                return {
                    'function': 'create_multipoint_animation',
                    'name': object_name,
                    'points': [
                        {'rotation': {'x': 0, 'y': 0, 'z': 0}},  # 起始旋转
                        {'rotation': rotation}  # 目标旋转
                    ],
                    'include_rotation': True,
                    'duration': extract_duration(description, default=2.0)
                }
        
        # 弹跳或简单动画
        if any(keyword in description for keyword in ['弹跳', '上下', '震动', '摆动']):
            return {
                'function': 'create_multipoint_animation',
                'name': object_name,
                'points': [
                    {'position': {'x': 0, 'y': 0, 'z': 0}},     # 起点
                    {'position': {'x': 0, 'y': 1, 'z': 0}},     # 中间点（上升）
                    {'position': {'x': 0, 'y': 0, 'z': 0}}      # 回到起点
                ],
                'duration': extract_duration(description, default=2.0)
            }
        
        # 如果无法识别，创建简单的默认动画（添加起点确保至少两个点）
        return {
            'function': 'create_multipoint_animation',
            'name': object_name,
            'points': [
                {'position': {'x': 0, 'y': 0, 'z': 0}},      # 起点
                {'position': {'x': 0, 'y': 0.5, 'z': 0}}     # 轻微上移
            ],
            'duration': extract_duration(description, default=3.0)
        }
        
    except Exception as e:
        return {'error': f"解析描述时出错: {str(e)}"}


def execute_animation_function(ctx: Context, params: Dict[str, Any]) -> str:
    """
    根据解析的参数执行相应的动画函数
    
    参数：
        ctx: MCP 上下文
        params: 动画参数字典
        
    返回值：
        str: 执行结果
    """
    function_name = params.get('function')
    
    if function_name == 'camera_panorama_animation':
        return camera_panorama_animation(
            ctx=ctx,
            camera_name=params.get('name', 'Main Camera'),
            pitch_angle=params.get('pitch_angle', -20.0),
            duration=params.get('duration', 10.0),
            timeline_asset_name=params.get('timeline_asset_name', 'CameraPanorama')
        )
    
    elif function_name == 'camera_sweep_animation':
        return camera_sweep_animation(
            ctx=ctx,
            camera_name=params.get('name', 'Main Camera'),
            pitch_angle=params.get('pitch_angle', 0.0),
            sweep_angle=params.get('sweep_angle', 45.0),
            duration=params.get('duration', 8.0),
            timeline_asset_name=params.get('timeline_asset_name', 'CameraSweep')
        )
    
    elif function_name == 'camera_closeup_animation':
        return camera_closeup_animation(
            ctx=ctx,
            camera_name=params.get('name', 'Main Camera'),
            target_object_name=params.get('target_object_name'),
            closeup_distance=params.get('closeup_distance', 3.0),
            duration=params.get('duration', 10.0),
            timeline_asset_name=params.get('timeline_asset_name', 'CameraCloseup')
        )
    
    elif function_name == 'rotate_around_target_animation':
        return rotate_around_target_animation(
            ctx=ctx,
            moving_object_name=params.get('moving_object_name'),
            target_object_name=params.get('target_object_name'),
            radius=params.get('radius', 5.0),
            height=params.get('height', 2.0),
            duration=params.get('duration', 8.0),
            timeline_asset_name=params.get('timeline_asset_name', 'RotationAroundTarget')
        )
    
    elif function_name == 'create_multipoint_animation':
        return create_multipoint_animation(
            ctx=ctx,
            name=params.get('name'),
            points=params.get('points', []),
            duration=params.get('duration', 3.0),
            timeline_asset_name=params.get('timeline_asset_name', 'MultipointAnimation'),
            include_rotation=params.get('include_rotation', False),
            enable_obstacle_avoidance=params.get('enable_obstacle_avoidance', False),
            obstacle_detection_radius=params.get('obstacle_detection_radius', 0.5),
            avoidance_height=params.get('avoidance_height', 2.0),
            obstacle_layers=params.get('obstacle_layers', None),
            max_avoidance_attempts=params.get('max_avoidance_attempts', 3)
        )
    
    else:
        return f"未知的动画函数: {function_name}"


# 辅助函数：从描述中提取数值
def extract_duration(description: str, default: float = 3.0) -> float:
    """从描述中提取持续时间"""
    import re
    
    # 匹配 "X秒" 或 "X s" 格式
    duration_match = re.search(r'(\d+(?:\.\d+)?)\s*[秒s]', description)
    if duration_match:
        return float(duration_match.group(1))
    
    # 匹配 "持续X" 格式
    duration_match = re.search(r'持续\s*(\d+(?:\.\d+)?)', description)
    if duration_match:
        return float(duration_match.group(1))
    
    return default


def extract_angle(description: str, default: float = 0.0) -> float:
    """从描述中提取角度"""
    import re
    
    # 俯视/仰视角度
    if '俯视' in description or '向下' in description:
        angle_match = re.search(r'俯视?\s*(\d+(?:\.\d+)?)', description)
        if angle_match:
            return float(angle_match.group(1))
        return 20.0  # 默认俯视角度
    
    if '仰视' in description or '向上' in description:
        angle_match = re.search(r'仰视?\s*(\d+(?:\.\d+)?)', description)
        if angle_match:
            return -float(angle_match.group(1))
        return -20.0  # 默认仰视角度
    
    # 匹配 "X度" 格式
    angle_match = re.search(r'(\d+(?:\.\d+)?)\s*度', description)
    if angle_match:
        return float(angle_match.group(1))
    
    return default


def extract_sweep_angle(description: str, default: float = 45.0) -> float:
    """从描述中提取扫视角度"""
    import re
    
    # 匹配扫视范围
    angle_match = re.search(r'扫视?\s*(\d+(?:\.\d+)?)\s*度', description)
    if angle_match:
        return float(angle_match.group(1))
    
    # 根据描述词推断
    if '大幅' in description or '宽' in description:
        return 60.0
    elif '小幅' in description or '窄' in description:
        return 30.0
    
    return default


def extract_distance(description: str, default: float = 5.0) -> float:
    """从描述中提取距离"""
    import re
    
    # 匹配 "X米" 或 "X单位" 格式
    distance_match = re.search(r'(\d+(?:\.\d+)?)\s*[米单位m]', description)
    if distance_match:
        return float(distance_match.group(1))
    
    # 根据描述词推断
    if '很近' in description or '紧' in description:
        return 2.0
    elif '很远' in description or '远' in description:
        return 10.0
    elif '适中' in description or '中等' in description:
        return 5.0
    
    return default


def extract_height(description: str, default: float = 2.0) -> float:
    """从描述中提取高度"""
    import re
    
    # 匹配高度描述
    height_match = re.search(r'高度?\s*(\d+(?:\.\d+)?)', description)
    if height_match:
        return float(height_match.group(1))
    
    # 根据描述词推断
    if '高' in description:
        return 5.0
    elif '低' in description:
        return 1.0
    
    return default


def extract_position(description: str) -> Dict[str, float]:
    """从描述中提取位置坐标"""
    import re
    
    # 解析方向词
    position = {'x': 0.0, 'y': 0.0, 'z': 0.0}
    
    # 前后移动
    if '前' in description:
        position['z'] = 5.0
    elif '后' in description:
        position['z'] = -5.0
    
    # 左右移动
    if '左' in description:
        position['x'] = -5.0
    elif '右' in description:
        position['x'] = 5.0
    
    # 上下移动  
    if '上' in description:
        position['y'] = 5.0
    elif '下' in description:
        position['y'] = -5.0
    
    # 解析具体坐标
    coord_match = re.search(r'(\d+(?:\.\d+)?)[,，]\s*(\d+(?:\.\d+)?)[,，]\s*(\d+(?:\.\d+)?)', description)
    if coord_match:
        position['x'] = float(coord_match.group(1))
        position['y'] = float(coord_match.group(2))
        position['z'] = float(coord_match.group(3))
    
    return position if any(v != 0.0 for v in position.values()) else None


def extract_rotation(description: str) -> Dict[str, float]:
    """从描述中提取旋转角度"""
    import re
    
    rotation = {'x': 0.0, 'y': 0.0, 'z': 0.0}
    
    # 水平旋转（Y轴）
    if '左转' in description:
        rotation['y'] = -90.0
    elif '右转' in description:
        rotation['y'] = 90.0
    elif '转身' in description or '掉头' in description:
        rotation['y'] = 180.0
    
    # 匹配具体旋转角度
    angle_match = re.search(r'旋转\s*(\d+(?:\.\d+)?)\s*度', description)
    if angle_match:
        rotation['y'] = float(angle_match.group(1))
    
    return rotation if any(v != 0.0 for v in rotation.values()) else None


def create_smart_movement_animation(
    ctx: Context,
    name: str,
    target_position: Dict[str, float],
    duration: float = 3.0,
    timeline_asset_name: str = "SmartMovementAnimation",
    enable_smart_avoidance: bool = True,
    obstacle_layers: Optional[List[str]] = None,
    avoidance_strategy: str = "adaptive"  # adaptive, high, side, normal
) -> str:
    """
    创建智能避障移动动画的便捷函数
    
    参数：
        ctx: MCP 上下文
        name: 要移动的物体名称
        target_position: 目标位置，格式为 {"x": 0, "y": 0, "z": 0}
        duration: 动画持续时间
        timeline_asset_name: Timeline资产名称
        enable_smart_avoidance: 是否启用智能避障
        obstacle_layers: 要检测的障碍物层级，默认为["Default", "Obstacle"]
        avoidance_strategy: 避障策略，可选值：
            - "adaptive": 自适应策略（默认）
            - "high": 优先向上避障
            - "side": 优先向侧面避障
            - "normal": 标准避障
            
    返回值：
        str: 创建结果消息
    """
    # 设置默认障碍物层级
    if obstacle_layers is None:
        obstacle_layers = ["Default", "Obstacle"]
    
    # 根据避障策略设置参数
    avoidance_params = {
        "adaptive": {"radius": 0.5, "height": 2.0, "attempts": 5},
        "high": {"radius": 0.3, "height": 3.0, "attempts": 3},
        "side": {"radius": 0.7, "height": 1.5, "attempts": 4},
        "normal": {"radius": 0.5, "height": 2.0, "attempts": 3}
    }
    
    params = avoidance_params.get(avoidance_strategy, avoidance_params["adaptive"])
    
    # 创建移动点
    points = [
        {"position": {"x": 0, "y": 0, "z": 0}},  # 起点（会自动调整为当前位置）
        {"position": target_position}  # 终点
    ]
    
    return create_multipoint_animation(
        ctx=ctx,
        name=name,
        points=points,
        duration=duration,
        timeline_asset_name=timeline_asset_name,
        enable_obstacle_avoidance=enable_smart_avoidance,
        obstacle_detection_radius=params["radius"],
        avoidance_height=params["height"],
        obstacle_layers=obstacle_layers,
        max_avoidance_attempts=params["attempts"]
    )


def create_safe_camera_movement(
    ctx: Context,
    camera_name: str = "Main Camera",
    target_object_name: str = None,
    movement_type: str = "orbit",  # orbit, approach, sweep
    enable_collision_avoidance: bool = True,
    safety_distance: float = 1.0
) -> str:
    """
    创建安全的相机移动动画，避免与场景物体碰撞
    
    参数：
        ctx: MCP 上下文
        camera_name: 相机名称
        target_object_name: 目标物体名称（用于orbit和approach模式）
        movement_type: 移动类型
            - "orbit": 围绕目标物体轨道运动
            - "approach": 接近目标物体
            - "sweep": 扫视运动
        enable_collision_avoidance: 是否启用碰撞避免
        safety_distance: 安全距离
        
    返回值：
        str: 创建结果消息
    """
    if movement_type == "orbit" and target_object_name:
        return rotate_around_target_animation(
            ctx=ctx,
            moving_object_name=camera_name,
            target_object_name=target_object_name,
            radius=5.0,
            height=2.0,
            duration=8.0,
            timeline_asset_name="SafeCameraOrbit"
        )
    elif movement_type == "approach" and target_object_name:
        return camera_closeup_animation(
            ctx=ctx,
            camera_name=camera_name,
            target_object_name=target_object_name,
            closeup_distance=safety_distance * 2,
            duration=6.0,
            timeline_asset_name="SafeCameraApproach"
        )
    elif movement_type == "sweep":
        return camera_sweep_animation(
            ctx=ctx,
            camera_name=camera_name,
            pitch_angle=0.0,
            sweep_angle=60.0,
            duration=8.0,
            timeline_asset_name="SafeCameraSweep"
        )
    else:
        return f"不支持的移动类型: {movement_type}，或缺少必要的目标物体参数" 